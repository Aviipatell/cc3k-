void moveEnemies() {
    std::string curMessage = getGameMessage();
    std::ostringstream o;

    int sizeHeight = this->floor.size();
    int sizeWidth = this->floor[0].size();

    for (int i = 0; i < sizeHeight; ++i) {
        for (int j = 0; j < sizeWidth; ++j) {
            if (floor[i][j]->hasEntity()) {
                bool playerIsNeighbour = false;
                Enemy* enemy = dynamic_cast<Enemy*>(floor[i][j]->getEntity());
                if (enemy != nullptr) {
                    if (!(enemy->getHasAlreadyMove())) {
                        std::vector<Cell*> enemyNeighbours = enemy->getNeighbours();
                        for (Cell* cell : enemyNeighbours) {
                            if (cell->getSymbol() == '@') {
                                playerIsNeighbour = true;
                                if (enemy->getIsHostile()) {
                                    enemy->attack(p);
                                } else {
                                    if (enemy->getIsGuardian()) {
                                        bool shouldAttack = false;
                                        std::vector<Item*> guardedItems = enemy->getGuardedItems();
                                        for (Item* item : guardedItems) {
                                            if (item->isNeighbour(cell)) {
                                                shouldAttack = true;
                                            }
                                        }
                                        if (shouldAttack) enemy->attack(p);
                                    }
                                }
                                break;
                            }
                        }
                        if (!(enemy->getIsGuardian())) {
                            if (!(playerisNeighbour)) {
                                Cell* newCell = getRandomValidNeighbour(floor[i][j]);
                                newCell->setEntity(enemy);
                                floor[i][j]->setEntity(nullptr);
                                enemy->setCell(newCell);
                            }
                        }
                    } else {
                        continue;
                    }
                }
            }
        }
    }
}
